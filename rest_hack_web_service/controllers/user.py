#
import logging
from flask import Flask, current_app, Blueprint, jsonify, request, redirect
from flask_login import (LoginManager, login_required, login_user,
                         current_user, logout_user, UserMixin)
from itsdangerous import URLSafeTimedSerializer
#
from models.user import User
#
from util.pass_hash import hash_pass

#
app = Flask(__name__)
logger = logging.getLogger(__name__)
user = Blueprint('user', __name__)

#Login_serializer used to encryt and decrypt the cookie token for the remember
#me option of flask-login
with app.app_context():
    login_serializer = URLSafeTimedSerializer(app.secret_key)

#Flask-Login Login Manager
login_manager = LoginManager()

#Tell the login manager where to redirect users to display the login page
login_manager.login_view = '/login'

@login_manager.user_loader
def load_user(userid):
    """
    Flask-Login user_loader callback.
    The user_loader function asks this function to get a User Object or return
    None based on the userid.
    The userid was stored in the session environment by Flask-Login.
    user_loader stores the returned User object in current_user during every
    flask request.
    """
    return User.get(userid)

@login_manager.token_loader
def load_token(token):
    """
    Flask-Login token_loader callback.
    The token_loader function asks this function to take the token that was
    stored on the users computer process it to check if its valid and then
    return a User Object if its valid or None if its not valid.
    """

    #The Token itself was generated by User.get_auth_token.  So it is up to
    #us to known the format of the token data itself.

    #The Token was encrypted using itsdangerous.URLSafeTimedSerializer which
    #allows us to have a max_age on the token itself.  When the cookie is stored
    #on the users computer it also has a exipry date, but could be changed by
    #the user, so this feature allows us to enforce the exipry date of the token
    #server side and not rely on the users cookie to exipre.
    max_age = app.config["REMEMBER_COOKIE_DURATION"].total_seconds()

    #Decrypt the Security Token, data = [username, hashpass]
    data = login_serializer.loads(token, max_age=max_age)

    #Find the User
    user = User.get(data[0])

    #Check Password and return user or None
    if user and data[1] == user.password:
        return user
    return None

@user.route('/logout')
def logout_page():
    logout_user()
    #return redirect("/")
    return jsonify({"logged out" : True})

@user.route('/login', methods=["GET", "POST"])
def login_page():
    logger.debug('/login')
    if request.method == "POST":
        user = User.get(request.form['username'])

        #If we found a user based on username then compare that the submitted
        #password matches the password in the database.  The password is stored
        #is a slated hash format, so you must hash the password before comparing
        #it.
        if user and hash_pass(request.form['password']) == user.password:
            login_user(user, remember=True)
            #return redirect(request.args.get("next") or "/")
            return jsonify({"logged in" : True})
        else:
            return jsonify({"logged in" : False})
    else:
        return jsonify({"message" : 'Please Login...'})

@user.record_once
def on_load(state):
    #Setup the login manager.
    #login_manager.setup_app(app)
    login_manager.init_app(state.app)
